"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.injectedClientEntries = void 0;
var _querystring = require("querystring");
var _webpack = require("next/dist/compiled/webpack/webpack");
var _constants = require("../../../shared/lib/constants");
var _utils = require("../loaders/utils");
var _normalizePagePath = require("../../../shared/lib/page-path/normalize-page-path");
var _denormalizePagePath = require("../../../shared/lib/page-path/denormalize-page-path");
var _onDemandEntryHandler = require("../../../server/dev/on-demand-entry-handler");
var _entries = require("../../entries");
const PLUGIN_NAME = 'FlightManifestPlugin';
let edgeFlightManifest = {};
let nodeFlightManifest = {};
const injectedClientEntries = new Map();
exports.injectedClientEntries = injectedClientEntries;
class FlightManifestPlugin {
    constructor(options){
        this.dev = false;
        if (typeof options.dev === 'boolean') {
            this.dev = options.dev;
        }
        this.pageExtensions = options.pageExtensions;
        this.isEdgeServer = options.isEdgeServer;
    }
    apply(compiler) {
        const context = this.context;
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, { normalModuleFactory  })=>{
            compilation.dependencyFactories.set(_webpack.webpack.dependencies.ModuleDependency, normalModuleFactory);
            compilation.dependencyTemplates.set(_webpack.webpack.dependencies.ModuleDependency, new _webpack.webpack.dependencies.NullDependency.Template());
        });
        // Only for webpack 5
        compiler.hooks.finishMake.tapAsync(PLUGIN_NAME, async (compilation, callback)=>{
            const promises = [];
            // For each SC server compilation entry, we need to create its corresponding
            // client component entry.
            for (const [name, entry] of compilation.entries.entries()){
                var ref, ref1;
                if (name === 'pages/_app.server') continue;
                // Check if the page entry is a server component or not.
                const entryDependency = (ref = entry.dependencies) === null || ref === void 0 ? void 0 : ref[0];
                const request = entryDependency === null || entryDependency === void 0 ? void 0 : entryDependency.request;
                if (request && ((ref1 = entry.options) === null || ref1 === void 0 ? void 0 : ref1.layer) === 'sc_server') {
                    const visited = new Set();
                    const clientComponentImports = [];
                    function filterClientComponents(dependency) {
                        const module = compilation.moduleGraph.getResolvedModule(dependency);
                        if (!module) return;
                        if (visited.has(module.userRequest)) return;
                        visited.add(module.userRequest);
                        if (_utils.clientComponentRegex.test(module.userRequest)) {
                            clientComponentImports.push(module.userRequest);
                        }
                        compilation.moduleGraph.getOutgoingConnections(module).forEach((connection)=>{
                            filterClientComponents(connection.dependency);
                        });
                    }
                    // Traverse the module graph to find all client components.
                    filterClientComponents(entryDependency);
                    const entryModule = compilation.moduleGraph.getResolvedModule(entryDependency);
                    const routeInfo = entryModule.buildInfo.route || {
                        page: (0, _denormalizePagePath).denormalizePagePath(name.replace(/^pages/, '')),
                        absolutePagePath: entryModule.resource
                    };
                    // Parse gSSP and gSP exports from the page source.
                    const pageStaticInfo = this.isEdgeServer ? {} : await (0, _entries).getPageStaticInfo(routeInfo.absolutePagePath, {}, this.dev);
                    const clientLoader = `next-flight-client-entry-loader?${(0, _querystring).stringify({
                        modules: clientComponentImports,
                        runtime: this.isEdgeServer ? 'edge' : 'nodejs',
                        ssr: pageStaticInfo.ssr,
                        // Adding name here to make the entry key unique.
                        name
                    })}!`;
                    const bundlePath = 'pages' + (0, _normalizePagePath).normalizePagePath(routeInfo.page);
                    // Inject the entry to the client compiler.
                    if (this.dev) {
                        const pageKey = 'client' + routeInfo.page;
                        if (!_onDemandEntryHandler.entries[pageKey]) {
                            _onDemandEntryHandler.entries[pageKey] = {
                                bundlePath,
                                absolutePagePath: routeInfo.absolutePagePath,
                                clientLoader,
                                dispose: false,
                                lastActiveTime: Date.now()
                            };
                            const invalidator = (0, _onDemandEntryHandler).getInvalidator();
                            if (invalidator) {
                                invalidator.invalidate();
                            }
                        }
                    } else {
                        injectedClientEntries.set(bundlePath, `next-client-pages-loader?${(0, _querystring).stringify({
                            isServerComponent: true,
                            page: (0, _denormalizePagePath).denormalizePagePath(bundlePath.replace(/^pages/, '')),
                            absolutePagePath: clientLoader
                        })}!` + clientLoader);
                    }
                    // Inject the entry to the server compiler.
                    const clientComponentEntryDep = _webpack.webpack.EntryPlugin.createDependency(clientLoader, name + '.__sc_client__');
                    promises.push(new Promise((res, rej)=>{
                        compilation.addEntry(context, clientComponentEntryDep, this.isEdgeServer ? {
                            name: name + '.__sc_client__',
                            library: {
                                name: [
                                    'self._CLIENT_ENTRY'
                                ],
                                type: 'assign'
                            },
                            runtime: _constants.EDGE_RUNTIME_WEBPACK,
                            asyncChunks: false
                        } : {
                            name: name + '.__sc_client__',
                            runtime: 'webpack-runtime'
                        }, (err)=>{
                            if (err) {
                                rej(err);
                            } else {
                                res();
                            }
                        });
                    }));
                }
            }
            Promise.all(promises).then(()=>callback()
            ).catch(callback);
        });
        compiler.hooks.make.tap(PLUGIN_NAME, (compilation)=>{
            compilation.hooks.processAssets.tap({
                name: PLUGIN_NAME,
                // @ts-ignore TODO: Remove ignore when webpack 5 is stable
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
            }, (assets)=>this.createAsset(assets, compilation)
            );
        });
    }
    createAsset(assets, compilation) {
        const manifest = {};
        compilation.chunkGroups.forEach((chunkGroup)=>{
            function recordModule(id, _chunk, mod) {
                const resource = mod.resource;
                // TODO: Hook into deps instead of the target module.
                // That way we know by the type of dep whether to include.
                // It also resolves conflicts when the same module is in multiple chunks.
                if (!resource || !_utils.clientComponentRegex.test(resource) || !_utils.clientComponentRegex.test(id)) {
                    return;
                }
                const moduleExports = manifest[resource] || {};
                const exportsInfo = compilation.moduleGraph.getExportsInfo(mod);
                const moduleExportedKeys = [
                    '',
                    '*'
                ].concat([
                    ...exportsInfo.exports
                ].map((exportInfo)=>{
                    if (exportInfo.provided) {
                        return exportInfo.name;
                    }
                    return null;
                }).filter(Boolean));
                moduleExportedKeys.forEach((name)=>{
                    if (!moduleExports[name]) {
                        moduleExports[name] = {
                            id: id.replace(/^\(sc_server\)\//, ''),
                            name,
                            chunks: []
                        };
                    }
                });
                manifest[resource] = moduleExports;
            }
            chunkGroup.chunks.forEach((chunk)=>{
                const chunkModules = compilation.chunkGraph.getChunkModulesIterable(chunk);
                for (const mod of chunkModules){
                    let modId = compilation.chunkGraph.getModuleId(mod);
                    if (typeof modId !== 'string') continue;
                    // Remove resource queries.
                    modId = modId.split('?')[0];
                    // Remove the loader prefix.
                    modId = modId.split('next-flight-client-loader.js!')[1] || modId;
                    recordModule(modId, chunk, mod);
                    // If this is a concatenation, register each child to the parent ID.
                    if (mod.modules) {
                        mod.modules.forEach((concatenatedMod)=>{
                            recordModule(modId, chunk, concatenatedMod);
                        });
                    }
                }
            });
        });
        // With switchable runtime, we need to emit the manifest files for both
        // runtimes.
        if (this.isEdgeServer) {
            edgeFlightManifest = manifest;
        } else {
            nodeFlightManifest = manifest;
        }
        const mergedManifest = {
            ...nodeFlightManifest,
            ...edgeFlightManifest
        };
        const file = (!this.dev && !this.isEdgeServer ? '../' : '') + _constants.MIDDLEWARE_FLIGHT_MANIFEST;
        const json = JSON.stringify(mergedManifest);
        assets[file + '.js'] = new _webpack.sources.RawSource('self.__RSC_MANIFEST=' + json);
        assets[file + '.json'] = new _webpack.sources.RawSource(json);
    }
}
exports.FlightManifestPlugin = FlightManifestPlugin;

//# sourceMappingURL=flight-manifest-plugin.js.map